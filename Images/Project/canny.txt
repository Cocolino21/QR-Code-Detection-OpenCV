Mat contrast_cu_mat_int(Mat img, int gout_min, int gout_max, int gin_min, int gin_max) {
	Mat dst = Mat(img.rows, img.cols, CV_8UC1);
	int gout = gout_max - gout_min;
	int gin = gin_max - gin_min;
	if (gin == 0) {
		gin = 1;
	}

	for (int i = 0; i < img.rows; i++) {
		for (int j = 0; j < img.cols; j++) {
			dst.at<uchar>(i, j) = gout_min + ((float)((float)(img.at<int>(i, j) - gin_min) / gin) * gout);
		}
	}
	return dst;
}

Mat filtru_trece_sus(Mat img, int values[]) {
	int di[] = { 0, -1, -1, -1, +0, +1, +1, +1, 0 };
	int dj[] = { 1, +1, +0, -1, -1, -1, +0, +1, 0 };
	Mat copy = img.clone();
	Mat interm = Mat::zeros(img.rows, img.cols, CV_32SC1);

	int min_val = 256;
	int max_val = -1;
	for (int i = 1; i < img.rows - 1; i++) {
		for (int j = 1; j < img.cols - 1; j++) {
			int val = 0;
			for (int k = 0; k < 9; k++) {
				int ii = di[k] + i;
				int jj = dj[k] + j;
				int value = values[k];
				val += img.at<uchar>(ii, jj) * value;
			}
			min_val = min(min_val, val);
			max_val = max(max_val, val);
			interm.at<int>(i, j) = val;
		}
	}

	Mat fin = contrast_cu_mat_int(interm, 0, 255, min_val, max_val);

	return fin;
}

Mat filtru_trece_sus_matrice_int(Mat img, int values[]) {
	int di[] = { 0, -1, -1, -1, +0, +1, +1, +1, 0 };
	int dj[] = { 1, +1, +0, -1, -1, -1, +0, +1, 0 };
	Mat copy = img.clone();
	Mat interm = Mat::zeros(img.rows, img.cols, CV_32SC1);

	int min_val = 256;
	int max_val = -1;
	for (int i = 1; i < img.rows - 1; i++) {
		for (int j = 1; j < img.cols - 1; j++) {
			int val = 0;
			for (int k = 0; k < 9; k++) {
				int ii = di[k] + i;
				int jj = dj[k] + j;
				int value = values[k];
				val += img.at<uchar>(ii, jj) * value;
			}
			min_val = min(min_val, val);
			max_val = max(max_val, val);
			interm.at<int>(i, j) = val;
		}
	}

	return interm;
}

Mat m_gradient(Mat ix, Mat iy) {
	Mat M = Mat(ix.rows, ix.cols, CV_32SC1);
	int minim = 456546;
	int maxim = -123124;
	for (int i = 0; i < ix.rows; i++) {
		for (int j = 0; j < ix.cols; j++) {
			M.at<int>(i, j) = sqrt(pow(ix.at<int>(i, j), 2) + pow(iy.at<int>(i, j), 2));
			minim = min(minim, M.at<int>(i, j));
			maxim = max(maxim, M.at<int>(i, j));
		}
	}
	//Mat M_uchar = contrast_cu_mat_int(M, 0, 255, minim, maxim);
	//imshow("M_uchar", M_uchar);
	return M;
}

Mat contrast_cu_mat_float(Mat img, int gout_min, int gout_max, float gin_min, float gin_max) {
	Mat dst = Mat(img.rows, img.cols, CV_8UC1);
	int gout = gout_max - gout_min;
	int gin = gin_max - gin_min;
	if (gin == 0) {
		gin = 1;
	}
	for (int i = 0; i < img.rows; i++) {
		for (int j = 0; j < img.cols; j++) {
			dst.at<uchar>(i, j) = gout_min + ((float)((float)(img.at<float>(i, j) - gin_min) / gin) * gout);
		}
	}
	return dst;
}

Mat teta_mat(Mat ix, Mat iy) {
	Mat teta = Mat(ix.rows, ix.cols, CV_32FC1);
	float minim = 456546;
	float maxim = -123124;
	for (int i = 0; i < ix.rows; i++) {
		for (int j = 0; j < ix.cols; j++) {
			teta.at<float>(i, j) = atan2(iy.at<int>(i,j), ix.at<int>(i,j));
			minim = min(minim, teta.at<float>(i, j));
			maxim = max(maxim, teta.at<float>(i, j));
		}
	}
	//Mat teta_uchar = contrast_cu_mat_float(teta, 0, 255, minim, maxim);
	//imshow("teta_uchar", teta_uchar);
	return teta;
}

Mat suprimare_non_maxime(Mat teta_gauss, Mat m_gauss) {
	Mat suprimat = Mat(teta_gauss.rows, teta_gauss.cols, CV_32SC1, cv::Scalar(0));
	int gin_min = 34543;
	int gin_max = -34543;
	for (int i = 1; i < teta_gauss.rows - 1; i++) {
		for (int j = 1; j < teta_gauss.cols - 1; j++) {
			float v = teta_gauss.at<float>(i, j);
			if (v < 0) {
				v += (2 * PI);
			}
			float x = (v * 180) / PI;
			if ((x > 22.5 && x < 67.5) || (x > 202.5 && x <= 247.5)) { // 1
				if (m_gauss.at<int>(i, j) > m_gauss.at<int>(i - 1, j + 1) && m_gauss.at<int>(i, j) > m_gauss.at<int>(i + 1, j - 1)) {
					suprimat.at<int>(i, j) = m_gauss.at<int>(i, j);
				}
			}
			else if ((x <= 22.5 && x >= 0) || (x <= 360 && x >= 337.5) || (x <= 202.5 && x > 157.5)) { // 2
				if (m_gauss.at<int>(i, j) > m_gauss.at<int>(i, j - 1) && m_gauss.at<int>(i, j) > m_gauss.at<int>(i, j+1)) {
					suprimat.at<int>(i, j) = m_gauss.at<int>(i, j);
				}
			} 
			else if ((x >= 112.5 && x <= 157.5) || (x > 292.5 && x < 337.5)) { // 3
				if (m_gauss.at<int>(i, j) > m_gauss.at<int>(i - 1, j - 1) && m_gauss.at<int>(i, j) > m_gauss.at<int>(i + 1, j + 1)) {
					suprimat.at<int>(i, j) = m_gauss.at<int>(i, j);
				}
			}
			else if ((x > 247.5 && x <= 292.5) || (x < 112.5 && x >= 67.5)) { // 0
				if (m_gauss.at<int>(i, j) > m_gauss.at<int>(i - 1, j) && m_gauss.at<int>(i, j) > m_gauss.at<int>(i + 1, j)) {
					suprimat.at<int>(i, j) = m_gauss.at<int>(i, j);
				}
			}
			gin_max = max(gin_max, suprimat.at<int>(i, j));
			gin_min = min(gin_min, suprimat.at<int>(i, j));

		}
	}

	Mat suprimat_uchar = contrast_cu_mat_int(suprimat, 0, 255, gin_min, gin_max);
	return suprimat_uchar;
}


Mat canny_final(Mat m) {

	Mat copy = m.clone();
	imshow("copy", copy);
	Mat visited = Mat::zeros(m.rows, m.cols, CV_8UC1);
	for (int i = 0; i < m.rows; i++) {
		for (int j = 0; j < m.cols; j++) {
			if (copy.at<uchar>(i, j) == 255) {
				std::vector<Point2i> q;
				q.push_back(Point2i(i, j));
				visited.at<uchar>(i, j) = 1;
				while (!q.empty()) {
					Point2i point = q.back();
					q.pop_back();
					if (point.x >= 0 && point.x < m.rows && point.y >= 0 && point.y < m.cols) {
						for (int k = -1; k <= 1; k++) {
							for (int v = -1; v <= 1; v++) {
								int ni = point.x + k;
								int nj = point.y + v;
								if (ni >= 0 && ni < m.rows && nj >= 0 && nj < m.cols) {
									if ((copy.at<uchar>(ni, nj) == 128 || copy.at<uchar>(ni, nj) == 255) && visited.at<uchar>(ni, nj) == 0) {
										copy.at<uchar>(ni, nj) = 255;
										q.push_back(Point2i(ni, nj));
										visited.at<uchar>(ni, nj) = 1;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	for (int i = 0; i < m.rows; i++) {
		for (int j = 0; j < m.cols; j++) {
			if (copy.at<uchar>(i, j) == 128) {
				copy.at<uchar>(i, j) = 0;
			}
		}
	}

	imshow("final", copy);
	return copy;
}


Mat canny_before_fin(Mat nnmax, int high_t, int low_t) {
	Mat copy = nnmax.clone();
	for (int i = 0; i < nnmax.rows; i++) {
		for (int j = 0; j < nnmax.cols; j++) {
			if (nnmax.at<uchar>(i, j) >= high_t) {
				copy.at<uchar>(i, j) = 255;
			}
			else if (nnmax.at<uchar>(i, j) < high_t && nnmax.at<uchar>(i,j) >= low_t) {
				copy.at<uchar>(i, j) = 128;
			}
			else if (nnmax.at<uchar>(i, j) < low_t) {
				copy.at<uchar>(i, j) = 0;
			}
		}
	}

	
	Mat fin = canny_final(copy);
	return fin;
}
void lab_11() {
	Mat img = imread("Images/saturn.bmp", IMREAD_GRAYSCALE);
	
	int dx_vec[] = { 2,1,0,-1,-2,-1,0,1,0 };
	Mat dx = filtru_trece_sus(img, dx_vec); // dx si dy nu face nimic cu ele doar le-am afisat ca sa le vada profa ca am calculat bine
	int dy_vec[] = { 0,1,2,1,0,-1,-2,-1,0 };
	Mat dy = filtru_trece_sus(img, dy_vec);

	Mat ix = filtru_trece_sus_matrice_int(img, dx_vec);
	Mat iy = filtru_trece_sus_matrice_int(img, dy_vec);

	Mat M = m_gradient(ix, iy);  // m = modul
	Mat teta = teta_mat(ix, iy); // teta = gradient

	/////////////        CANNY
	int gauss_values[] = { 2,1,2,1,2,1,2,1,4 };
	Mat gaus = filtru_trece_jos(img, gauss_values);

	Mat ix_gauss = filtru_trece_sus_matrice_int(gaus, dx_vec);
	Mat iy_gauss = filtru_trece_sus_matrice_int(gaus, dy_vec);

	Mat M_gauss = m_gradient(ix_gauss, iy_gauss);
	Mat teta_gauss = teta_mat(ix_gauss, iy_gauss);

	Mat nnmax = suprimare_non_maxime(teta_gauss, M_gauss);

	std::vector<int> hist(255, 0);
	for (int i = 0; i < nnmax.rows; i++) {
		for (int j = 0; j < nnmax.cols; j++) {
			hist[(int)nnmax.at<uchar>(i, j)]++;
		}
	}
	float p = 0.1;
	int nr_non_muchie = (1 - p) * ((nnmax.rows * nnmax.cols) - hist[0]);
	int sum = 0;

	int high_t;
	for (int i = 1; i <= 255; i++) {
		sum += hist[i];
		if (sum > nr_non_muchie) {
			high_t = i;
			break;
		}
	}
	float k = 0.5;
	int low_t = k * high_t;
	canny_before_fin(nnmax, high_t, low_t);

	imshow("img", img);
	/*imshow("dx", dx);
	imshow("dy", dy);*/
	waitKey(0);
}

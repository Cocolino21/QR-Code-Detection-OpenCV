<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opera»õii Morfologice - Demonstra»õii Live</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .content {
            padding: 30px;
        }

        .operation-section {
            margin-bottom: 50px;
            padding: 30px;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            background: #f8f9fa;
        }

        .operation-title {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .step-by-step {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .grid-demo {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin: 25px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .grid {
            display: inline-grid;
            gap: 2px;
            background: #343a40;
            padding: 15px;
            border-radius: 8px;
            border: 3px solid #6c757d;
        }

        .cell {
            width: 35px;
            height: 35px;
            border: 1px solid #495057;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .cell.object {
            background: #212529;
            color: white;
        }

        .cell.background {
            background: #f8f9fa;
            color: #212529;
        }

        .cell.highlight {
            background: #ff6b6b !important;
            color: white;
            animation: pulse 1.5s infinite;
            border: 2px solid #ff4757;
        }

        .cell.processing {
            background: #ffa726 !important;
            color: white;
            border: 2px solid #f57c00;
        }

        .cell.result {
            background: #66bb6a !important;
            color: white;
            border: 2px solid #4caf50;
        }

        .cell.kernel-center {
            background: #e91e63 !important;
            color: white;
            border: 3px solid #ad1457;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.15); opacity: 0.8; }
        }

        .grid-label {
            text-align: center;
            font-weight: bold;
            margin: 15px 0;
            color: #2c3e50;
            font-size: 16px;
            padding: 8px 16px;
            background: #e3f2fd;
            border-radius: 20px;
            display: inline-block;
        }

        .arrow {
            font-size: 32px;
            color: #3498db;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .explanation-box {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .explanation-box h4 {
            color: #2e7d32;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }

        .algorithm-box {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .algorithm-box h4 {
            color: #f57c00;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }

        .interactive-controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }

        .btn.reset {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .btn.step {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .btn:disabled {
            background: #bdc3c7 !important;
            cursor: not-allowed !important;
            transform: none !important;
        }

        .coordinate-info {
            font-family: 'Courier New', monospace;
            background: #263238;
            color: #4fc3f7;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            margin: 10px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4caf50, #2e7d32);
            width: 0%;
            transition: width 0.5s ease;
        }

        .current-step {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-weight: bold;
            color: #0c5460;
        }

        .matrix-notation {
            font-family: 'Courier New', monospace;
            background: #263238;
            color: #4fc3f7;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            margin: 15px 0;
            white-space: pre-line;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-table th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .highlight-text {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: #856404;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Opera»õii Morfologice - Demonstra»õii Live</h1>
            <p>TransformƒÉri pas cu pas pe pixeli cu exemple interactive</p>
        </div>

        <div class="content">
            <!-- CONCEPTE FUNDAMENTALE -->
            <div class="operation-section">
                <h2 class="operation-title">üìö Concepte Fundamentale</h2>
                
                <div class="explanation-box">
                    <h4>üéØ Ce sunt Opera»õiile Morfologice?</h4>
                    <p><strong>Morfologia</strong> = studiul formei »ôi structurii</p>
                    <p><strong>Opera»õiile morfologice</strong> modificƒÉ forma obiectelor din imagini prin:</p>
                    <ul>
                        <li><span class="highlight-text">Dilatarea</span> - mƒÉrirea obiectelor</li>
                        <li><span class="highlight-text">Eroziunea</span> - mic»ôorarea obiectelor</li>
                        <li><span class="highlight-text">Combina»õii</span> - deschidere, √Ænchidere, etc.</li>
                    </ul>
                </div>

                <div class="step-by-step">
                    <h4>üóÇÔ∏è Nota»õii »ôi Conven»õii</h4>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #212529;"></div>
                            <span><strong>Pixel OBIECT</strong> (1, negru)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f8f9fa;"></div>
                            <span><strong>Pixel FUNDAL</strong> (0, alb)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b6b;"></div>
                            <span><strong>Pixel PROCESAT</strong></span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #e91e63;"></div>
                            <span><strong>Centrul Elementului</strong></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- DILATAREA -->
            <div class="operation-section">
                <h2 class="operation-title">üîç 1. DILATAREA (A ‚äï B)</h2>
                
                <div class="explanation-box">
                    <h4>üìñ Defini»õia</h4>
                    <p><strong>Dilatarea</strong> mƒÉre»ôte obiectele prin adƒÉugarea de pixeli la marginile lor.</p>
                    <p><strong>Regula:</strong> DacƒÉ originea elementului structural se suprapune cu un pixel OBIECT, to»õi pixelii acoperi»õi de element devin OBIECT √Æn rezultat.</p>
                </div>

                <div class="step-by-step">
                    <h4>üé¨ Demonstra»õie InteractivƒÉ - Dilatarea</h4>
                    
                    <div class="grid-demo">
                        <div>
                            <div class="grid-label">Imaginea A (5√ó5)</div>
                            <div class="grid" id="dilationImageA" style="grid-template-columns: repeat(5, 1fr);"></div>
                            <div class="coordinate-info">
                                Click pe pixeli pentru a-i modifica
                                1 = OBIECT, 0 = FUNDAL
                            </div>
                        </div>

                        <div class="arrow">‚äï</div>

                        <div>
                            <div class="grid-label">Element Structural B</div>
                            <div class="grid" id="dilationKernelB" style="grid-template-columns: repeat(3, 1fr);"></div>
                            <div class="coordinate-info">
                                Cruce 3√ó3
                                Centrul = origine
                            </div>
                        </div>

                        <div class="arrow">=</div>

                        <div>
                            <div class="grid-label">Rezultat (A ‚äï B)</div>
                            <div class="grid" id="dilationResult" style="grid-template-columns: repeat(5, 1fr);"></div>
                            <div class="coordinate-info">
                                Pixeli adƒÉuga»õi: <span id="dilationCount">0</span>
                            </div>
                        </div>
                    </div>

                    <div class="interactive-controls">
                        <button class="btn" onclick="performDilation()">üîÑ AplicƒÉ Dilatarea</button>
                        <button class="btn" onclick="startDilationAnimation()">‚ñ∂Ô∏è Anima»õie Pas cu Pas</button>
                        <button class="btn reset" onclick="resetDilation()">üîÑ Reset</button>
                        <div class="progress-bar">
                            <div class="progress-fill" id="dilationProgress"></div>
                        </div>
                        <div class="current-step" id="dilationStepInfo">ModificƒÉ imaginea »ôi apasƒÉ "AplicƒÉ Dilatarea"</div>
                    </div>

                    <div class="algorithm-box">
                        <h4>üî¢ Algoritmul DilatƒÉrii</h4>
                        <div class="matrix-notation">Pentru fiecare pixel (i,j) din imaginea A:
  DacƒÉ A[i,j] == 1 (OBIECT):
    Pentru fiecare pixel (u,v) din elementul structural B:
      DacƒÉ B[u,v] == 1:
        x = i + u - 1  // u-1 pentru cƒÉ centrul B este la (1,1)
        y = j + v - 1  // v-1 pentru cƒÉ centrul B este la (1,1)
        DacƒÉ (x,y) sunt coordonate valide:
          Rezultat[x,y] = 1

Exemplu: DacƒÉ A[2,2] = 1 »ôi B este cruce 3√ó3
‚Üí Rezultat[1,2] = 1, Rezultat[2,1] = 1, Rezultat[2,2] = 1, 
  Rezultat[2,3] = 1, Rezultat[3,2] = 1</div>
                    </div>
                </div>
            </div>

            <!-- EROZIUNEA -->
            <div class="operation-section">
                <h2 class="operation-title">üîç 2. EROZIUNEA (A Œò B)</h2>
                
                <div class="explanation-box">
                    <h4>üìñ Defini»õia</h4>
                    <p><strong>Eroziunea</strong> mic»ôoreazƒÉ obiectele prin eliminarea pixelilor de la margini.</p>
                    <p><strong>Regula:</strong> Un pixel devine OBIECT √Æn rezultat DOAR dacƒÉ elementul structural se potrive»ôte complet cu pixeli OBIECT.</p>
                </div>

                <div class="step-by-step">
                    <h4>üé¨ Demonstra»õie InteractivƒÉ - Eroziunea</h4>
                    
                    <div class="grid-demo">
                        <div>
                            <div class="grid-label">Imaginea A (5√ó5)</div>
                            <div class="grid" id="erosionImageA" style="grid-template-columns: repeat(5, 1fr);"></div>
                            <div class="coordinate-info">
                                Click pentru a modifica pixelii
                            </div>
                        </div>

                        <div class="arrow">Œò</div>

                        <div>
                            <div class="grid-label">Element Structural B</div>
                            <div class="grid" id="erosionKernelB" style="grid-template-columns: repeat(3, 1fr);"></div>
                            <div class="coordinate-info">
                                VerificƒÉ potrivirea completƒÉ
                            </div>
                        </div>

                        <div class="arrow">=</div>

                        <div>
                            <div class="grid-label">Rezultat (A Œò B)</div>
                            <div class="grid" id="erosionResult" style="grid-template-columns: repeat(5, 1fr);"></div>
                            <div class="coordinate-info">
                                Pixeli rƒÉma»ôi: <span id="erosionCount">0</span>
                            </div>
                        </div>
                    </div>

                    <div class="interactive-controls">
                        <button class="btn" onclick="performErosion()">üîÑ AplicƒÉ Eroziunea</button>
                        <button class="btn" onclick="startErosionAnimation()">‚ñ∂Ô∏è Anima»õie Pas cu Pas</button>
                        <button class="btn reset" onclick="resetErosion()">üîÑ Reset</button>
                        <div class="progress-bar">
                            <div class="progress-fill" id="erosionProgress"></div>
                        </div>
                        <div class="current-step" id="erosionStepInfo">ModificƒÉ imaginea »ôi apasƒÉ "AplicƒÉ Eroziunea"</div>
                    </div>

                    <div class="algorithm-box">
                        <h4>üî¢ Algoritmul Eroziunii</h4>
                        <div class="matrix-notation">Pentru fiecare pixel (i,j) din imaginea A:
  potrivire_completa = true
  
  Pentru fiecare pixel (u,v) din elementul structural B:
    DacƒÉ B[u,v] == 1:  // numai pentru pixelii activi din B
      x = i + u - 1
      y = j + v - 1
      DacƒÉ (x,y) sunt √Æn afara imaginii SAU A[x,y] == 0:
        potrivire_completa = false
        BREAK
  
  DacƒÉ potrivire_completa == true:
    Rezultat[i,j] = 1
  Altfel:
    Rezultat[i,j] = 0

Exemplu: Pentru a verifica A[2,2] cu cruce 3√ó3
‚Üí VerificƒÉ A[1,2], A[2,1], A[2,2], A[2,3], A[3,2]
‚Üí DacƒÉ TO»öI sunt 1, atunci Rezultat[2,2] = 1</div>
                    </div>
                </div>
            </div>

            <!-- DESCHIDEREA -->
            <div class="operation-section">
                <h2 class="operation-title">üîç 3. DESCHIDEREA (A ‚ó¶ B)</h2>
                
                <div class="explanation-box">
                    <h4>üìñ Defini»õia</h4>
                    <p><strong>Deschiderea</strong> = Eroziune urmatƒÉ de Dilatare</p>
                    <p><strong>Formula:</strong> A ‚ó¶ B = (A Œò B) ‚äï B</p>
                    <p><strong>Efectul:</strong> EliminƒÉ obiectele mici »ôi neteze»ôte contururile</p>
                </div>

                <div class="step-by-step">
                    <h4>üé¨ Demonstra»õie InteractivƒÉ - Deschiderea</h4>
                    
                    <div class="grid-demo">
                        <div>
                            <div class="grid-label">Imaginea OriginalƒÉ</div>
                            <div class="grid" id="openingOriginal" style="grid-template-columns: repeat(6, 1fr);"></div>
                        </div>

                        <div class="arrow">‚Üí</div>

                        <div>
                            <div class="grid-label">DupƒÉ Eroziune</div>
                            <div class="grid" id="openingEroded" style="grid-template-columns: repeat(6, 1fr);"></div>
                        </div>

                        <div class="arrow">‚Üí</div>

                        <div>
                            <div class="grid-label">Rezultat Final</div>
                            <div class="grid" id="openingFinal" style="grid-template-columns: repeat(6, 1fr);"></div>
                        </div>
                    </div>

                    <div class="interactive-controls">
                        <button class="btn" onclick="performOpening()">üîÑ AplicƒÉ Deschiderea</button>
                        <button class="btn" onclick="presetOpeningNoisy()">üìù Preset: Cu Zgomot</button>
                        <button class="btn reset" onclick="resetOpening()">üîÑ Reset</button>
                        <div class="progress-bar">
                            <div class="progress-fill" id="openingProgress"></div>
                        </div>
                        <div class="current-step" id="openingStepInfo">ObservƒÉ cum obiectele mici sunt eliminate</div>
                    </div>
                </div>
            </div>

            <!-- √éNCHIDEREA -->
            <div class="operation-section">
                <h2 class="operation-title">üîç 4. √éNCHIDEREA (A ‚Ä¢ B)</h2>
                
                <div class="explanation-box">
                    <h4>üìñ Defini»õia</h4>
                    <p><strong>√énchiderea</strong> = Dilatare urmatƒÉ de Eroziune</p>
                    <p><strong>Formula:</strong> A ‚Ä¢ B = (A ‚äï B) Œò B</p>
                    <p><strong>Efectul:</strong> Umple golurile »ôi conecteazƒÉ obiectele apropiate</p>
                </div>

                <div class="step-by-step">
                    <h4>üé¨ Demonstra»õie InteractivƒÉ - √énchiderea</h4>
                    
                    <div class="grid-demo">
                        <div>
                            <div class="grid-label">Imaginea cu Goluri</div>
                            <div class="grid" id="closingOriginal" style="grid-template-columns: repeat(6, 1fr);"></div>
                        </div>

                        <div class="arrow">‚Üí</div>

                        <div>
                            <div class="grid-label">DupƒÉ Dilatare</div>
                            <div class="grid" id="closingDilated" style="grid-template-columns: repeat(6, 1fr);"></div>
                        </div>

                        <div class="arrow">‚Üí</div>

                        <div>
                            <div class="grid-label">Rezultat Final</div>
                            <div class="grid" id="closingFinal" style="grid-template-columns: repeat(6, 1fr);"></div>
                        </div>
                    </div>

                    <div class="interactive-controls">
                        <button class="btn" onclick="performClosing()">üîÑ AplicƒÉ √énchiderea</button>
                        <button class="btn" onclick="presetClosingGaps()">üìù Preset: Cu Goluri</button>
                        <button class="btn reset" onclick="resetClosing()">üîÑ Reset</button>
                        <div class="progress-bar">
                            <div class="progress-fill" id="closingProgress"></div>
                        </div>
                        <div class="current-step" id="closingStepInfo">ObservƒÉ cum golurile sunt umplute</div>
                    </div>
                </div>
            </div>

            <!-- COMPARA»öIA OPERA»öIILOR -->
            <div class="operation-section">
                <h2 class="operation-title">üìä Compara»õia Opera»õiilor</h2>
                
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Opera»õia</th>
                            <th>Formula</th>
                            <th>Efectul Principal</th>
                            <th>Utilizare</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Dilatarea</strong></td>
                            <td>A ‚äï B</td>
                            <td>MƒÉre»ôte obiectele</td>
                            <td>Umplerea golurilor, conectarea obiectelor</td>
                        </tr>
                        <tr>
                            <td><strong>Eroziunea</strong></td>
                            <td>A Œò B</td>
                            <td>Mic»ôoreazƒÉ obiectele</td>
                            <td>Eliminarea zgomotului, separarea obiectelor</td>
                        </tr>
                        <tr>
                            <td><strong>Deschiderea</strong></td>
                            <td>(A Œò B) ‚äï B</td>
                            <td>EliminƒÉ obiectele mici</td>
                            <td>Filtrarea obiectelor mici, netezirea contururilor</td>
                        </tr>
                        <tr>
                            <td><strong>√énchiderea</strong></td>
                            <td>(A ‚äï B) Œò B</td>
                            <td>Umple golurile mici</td>
                            <td>Conectarea obiectelor, umplerea gƒÉurilor</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Structuri de date pentru fiecare opera»õie
        let dilationData = {
            imageA: [0,0,0,0,0, 0,1,0,1,0, 0,0,0,0,0, 0,1,0,0,0, 0,0,0,0,0],
            kernel: [0,1,0, 1,1,1, 0,1,0], // cruce 3x3
            result: Array(25).fill(0),
            animationStep: 0,
            isAnimating: false
        };

        let erosionData = {
            imageA: [0,0,0,0,0, 0,1,1,1,0, 0,1,1,1,0, 0,1,1,1,0, 0,0,0,0,0],
            kernel: [0,1,0, 1,1,1, 0,1,0], // cruce 3x3
            result: Array(25).fill(0),
            animationStep: 0,
            isAnimating: false
        };

        let openingData = {
            original: [0,0,0,0,0,0, 0,1,0,1,0,0, 0,0,1,1,1,0, 1,0,1,1,0,0, 0,0,1,1,1,0, 0,0,0,0,0,0],
            eroded: Array(36).fill(0),
            final: Array(36).fill(0)
        };

        let closingData = {
            original: [0,0,0,0,0,0, 0,1,1,0,1,0, 0,1,0,0,1,0, 0,1,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
            dilated: Array(36).fill(0),
            final: Array(36).fill(0)
        };

        // Ini»õializare la √ÆncƒÉrcarea paginii
        document.addEventListener('DOMContentLoaded', function() {
            initializeAllOperations();
        });

        function initializeAllOperations() {
            renderDilationGrids();
            renderErosionGrids();
            renderOpeningGrids();
            renderClosingGrids();
        }

        // === FUNC»öII HELPER ===
        function renderGrid(elementId, data, size, interactive = false, operationType = '') {
            const grid = document.getElementById(elementId);
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let i = 0; i < data.length; i++) {
                const cell = document.createElement('div');
                cell.className = `cell ${data[i] === 1 ? 'object' : 'background'}`;
                cell.textContent = data[i];
                
                if (interactive) {
                    cell.addEventListener('click', () => togglePixel(operationType, i));
                }
                
                // Pentru kernel, marcheazƒÉ centrul
                if (elementId.includes('Kernel') && size === 3 && i === 4) {
                    cell.classList.add('kernel-center');
                }
                
                grid.appendChild(cell);
            }
        }

        function togglePixel(operationType, index) {
            if (operationType === 'dilation') {
                dilationData.imageA[index] = dilationData.imageA[index] === 1 ? 0 : 1;
                renderDilationGrids();
            } else if (operationType === 'erosion') {
                erosionData.imageA[index] = erosionData.imageA[index] === 1 ? 0 : 1;
                renderErosionGrids();
            }
        }

        function updateProgress(elementId, progress) {
            const progressBar = document.getElementById(elementId);
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
        }

        function updateStepInfo(elementId, message) {
            const stepInfo = document.getElementById(elementId);
            if (stepInfo) {
                stepInfo.textContent = message;
            }
        }

        // === FUNC»öII PENTRU DILATARE ===
        function renderDilationGrids() {
            renderGrid('dilationImageA', dilationData.imageA, 5, true, 'dilation');
            renderGrid('dilationKernelB', dilationData.kernel, 3, false);
            renderGrid('dilationResult', dilationData.result, 5, false);
            
            const count = dilationData.result.filter(x => x === 1).length;
            document.getElementById('dilationCount').textContent = count;
        }

        function performDilation() {
            const imageA = dilationData.imageA;
            const kernel = dilationData.kernel;
            const result = Array(25).fill(0);
            
            // Pentru fiecare pixel din imaginea A
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    const pixelIndex = i * 5 + j;
                    
                    if (imageA[pixelIndex] === 1) { // DacƒÉ pixelul este OBIECT
                        // AplicƒÉ elementul structural
                        for (let u = 0; u < 3; u++) {
                            for (let v = 0; v < 3; v++) {
                                const kernelIndex = u * 3 + v;
                                
                                if (kernel[kernelIndex] === 1) {
                                    const newI = i + u - 1; // -1 pentru cƒÉ centrul kernel-ului este la (1,1)
                                    const newJ = j + v - 1;
                                    
                                    // VerificƒÉ dacƒÉ coordonatele sunt valide
                                    if (newI >= 0 && newI < 5 && newJ >= 0 && newJ < 5) {
                                        const resultIndex = newI * 5 + newJ;
                                        result[resultIndex] = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            dilationData.result = result;
            renderDilationGrids();
            updateStepInfo('dilationStepInfo', 'Dilatare aplicatƒÉ! ObservƒÉ cum obiectele s-au mƒÉrit.');
            updateProgress('dilationProgress', 100);
        }

        function startDilationAnimation() {
            if (dilationData.isAnimating) return;
            
            dilationData.isAnimating = true;
            dilationData.animationStep = 0;
            
            const imageA = dilationData.imageA;
            const result = Array(25).fill(0);
            const objectPixels = [];
            
            // GƒÉse»ôte to»õi pixelii OBIECT
            for (let i = 0; i < 25; i++) {
                if (imageA[i] === 1) {
                    objectPixels.push(i);
                }
            }
            
            if (objectPixels.length === 0) {
                dilationData.isAnimating = false;
                updateStepInfo('dilationStepInfo', 'Nu existƒÉ pixeli OBIECT pentru dilatare!');
                return;
            }
            
            function animateStep() {
                if (dilationData.animationStep >= objectPixels.length) {
                    dilationData.isAnimating = false;
                    dilationData.result = result;
                    renderDilationGrids();
                    updateStepInfo('dilationStepInfo', 'Anima»õia s-a terminat! Dilatarea este completƒÉ.');
                    updateProgress('dilationProgress', 100);
                    return;
                }
                
                const pixelIndex = objectPixels[dilationData.animationStep];
                const i = Math.floor(pixelIndex / 5);
                const j = pixelIndex % 5;
                
                // Eviden»õiazƒÉ pixelul curent
                const currentCell = document.querySelector(`#dilationImageA .cell:nth-child(${pixelIndex + 1})`);
                if (currentCell) {
                    currentCell.classList.add('highlight');
                    setTimeout(() => currentCell.classList.remove('highlight'), 1000);
                }
                
                // AplicƒÉ elementul structural pentru acest pixel
                for (let u = 0; u < 3; u++) {
                    for (let v = 0; v < 3; v++) {
                        const kernelIndex = u * 3 + v;
                        
                        if (dilationData.kernel[kernelIndex] === 1) {
                            const newI = i + u - 1;
                            const newJ = j + v - 1;
                            
                            if (newI >= 0 && newI < 5 && newJ >= 0 && newJ < 5) {
                                const resultIndex = newI * 5 + newJ;
                                result[resultIndex] = 1;
                            }
                        }
                    }
                }
                
                dilationData.result = result;
                renderDilationGrids();
                
                const progress = ((dilationData.animationStep + 1) / objectPixels.length) * 100;
                updateProgress('dilationProgress', progress);
                updateStepInfo('dilationStepInfo', `Procesez pixelul ${dilationData.animationStep + 1}/${objectPixels.length} la pozi»õia (${i}, ${j})`);
                
                dilationData.animationStep++;
                setTimeout(animateStep, 1500);
            }
            
            animateStep();
        }

        function resetDilation() {
            dilationData.imageA = [0,0,0,0,0, 0,1,0,1,0, 0,0,0,0,0, 0,1,0,0,0, 0,0,0,0,0];
            dilationData.result = Array(25).fill(0);
            dilationData.isAnimating = false;
            dilationData.animationStep = 0;
            renderDilationGrids();
            updateProgress('dilationProgress', 0);
            updateStepInfo('dilationStepInfo', 'Reset complet! ModificƒÉ imaginea »ôi apasƒÉ "AplicƒÉ Dilatarea"');
        }

        // === FUNC»öII PENTRU EROZIUNE ===
        function renderErosionGrids() {
            renderGrid('erosionImageA', erosionData.imageA, 5, true, 'erosion');
            renderGrid('erosionKernelB', erosionData.kernel, 3, false);
            renderGrid('erosionResult', erosionData.result, 5, false);
            
            const count = erosionData.result.filter(x => x === 1).length;
            document.getElementById('erosionCount').textContent = count;
        }

        function performErosion() {
            const imageA = erosionData.imageA;
            const kernel = erosionData.kernel;
            const result = Array(25).fill(0);
            
            // Pentru fiecare pixel din imaginea A
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    let completeMatch = true;
                    
                    // VerificƒÉ dacƒÉ elementul structural se potrive»ôte complet
                    for (let u = 0; u < 3; u++) {
                        for (let v = 0; v < 3; v++) {
                            const kernelIndex = u * 3 + v;
                            
                            if (kernel[kernelIndex] === 1) {
                                const checkI = i + u - 1;
                                const checkJ = j + v - 1;
                                
                                // VerificƒÉ dacƒÉ coordonatele sunt √Æn afara imaginii sau pixelul nu este OBIECT
                                if (checkI < 0 || checkI >= 5 || checkJ < 0 || checkJ >= 5) {
                                    completeMatch = false;
                                    break;
                                }
                                
                                const checkIndex = checkI * 5 + checkJ;
                                if (imageA[checkIndex] === 0) {
                                    completeMatch = false;
                                    break;
                                }
                            }
                        }
                        if (!completeMatch) break;
                    }
                    
                    if (completeMatch) {
                        const resultIndex = i * 5 + j;
                        result[resultIndex] = 1;
                    }
                }
            }
            
            erosionData.result = result;
            renderErosionGrids();
            updateStepInfo('erosionStepInfo', 'Eroziune aplicatƒÉ! ObservƒÉ cum obiectele s-au mic»ôorat.');
            updateProgress('erosionProgress', 100);
        }

        function startErosionAnimation() {
            if (erosionData.isAnimating) return;
            
            erosionData.isAnimating = true;
            erosionData.animationStep = 0;
            
            const imageA = erosionData.imageA;
            const result = Array(25).fill(0);
            const totalPixels = 25;
            
            function animateStep() {
                if (erosionData.animationStep >= totalPixels) {
                    erosionData.isAnimating = false;
                    erosionData.result = result;
                    renderErosionGrids();
                    updateStepInfo('erosionStepInfo', 'Anima»õia s-a terminat! Eroziunea este completƒÉ.');
                    updateProgress('erosionProgress', 100);
                    return;
                }
                
                const pixelIndex = erosionData.animationStep;
                const i = Math.floor(pixelIndex / 5);
                const j = pixelIndex % 5;
                
                // Eviden»õiazƒÉ pixelul curent
                const currentCell = document.querySelector(`#erosionImageA .cell:nth-child(${pixelIndex + 1})`);
                if (currentCell) {
                    currentCell.classList.add('highlight');
                    setTimeout(() => currentCell.classList.remove('highlight'), 1000);
                }
                
                // VerificƒÉ dacƒÉ elementul structural se potrive»ôte complet
                let completeMatch = true;
                for (let u = 0; u < 3; u++) {
                    for (let v = 0; v < 3; v++) {
                        const kernelIndex = u * 3 + v;
                        
                        if (erosionData.kernel[kernelIndex] === 1) {
                            const checkI = i + u - 1;
                            const checkJ = j + v - 1;
                            
                            if (checkI < 0 || checkI >= 5 || checkJ < 0 || checkJ >= 5) {
                                completeMatch = false;
                                break;
                            }
                            
                            const checkIndex = checkI * 5 + checkJ;
                            if (imageA[checkIndex] === 0) {
                                completeMatch = false;
                                break;
                            }
                        }
                    }
                    if (!completeMatch) break;
                }
                
                if (completeMatch) {
                    result[pixelIndex] = 1;
                }
                
                erosionData.result = [...result];
                renderErosionGrids();
                
                const progress = ((erosionData.animationStep + 1) / totalPixels) * 100;
                updateProgress('erosionProgress', progress);
                updateStepInfo('erosionStepInfo', `Verific pixelul la pozi»õia (${i}, ${j}) - ${completeMatch ? 'POTRIVIRE' : 'NU SE POTRIVE»òTE'}`);
                
                erosionData.animationStep++;
                setTimeout(animateStep, 800);
            }
            
            animateStep();
        }

        function resetErosion() {
            erosionData.imageA = [0,0,0,0,0, 0,1,1,1,0, 0,1,1,1,0, 0,1,1,1,0, 0,0,0,0,0];
            erosionData.result = Array(25).fill(0);
            erosionData.isAnimating = false;
            erosionData.animationStep = 0;
            renderErosionGrids();
            updateProgress('erosionProgress', 0);
            updateStepInfo('erosionStepInfo', 'Reset complet! ModificƒÉ imaginea »ôi apasƒÉ "AplicƒÉ Eroziunea"');
        }

        // === FUNC»öII PENTRU DESCHIDERE ===
        function renderOpeningGrids() {
            renderGrid('openingOriginal', openingData.original, 6, true, 'opening');
            renderGrid('openingEroded', openingData.eroded, 6, false);
            renderGrid('openingFinal', openingData.final, 6, false);
        }

        function performOpening() {
            // Pasul 1: Eroziune
            const eroded = performErosionOn6x6(openingData.original);
            openingData.eroded = eroded;
            
            // Pasul 2: Dilatare pe rezultatul eroziunii
            const final = performDilationOn6x6(eroded);
            openingData.final = final;
            
            renderOpeningGrids();
            updateStepInfo('openingStepInfo', 'Deschidere aplicatƒÉ! Obiectele mici au fost eliminate.');
            updateProgress('openingProgress', 100);
        }

        function performErosionOn6x6(image) {
            const result = Array(36).fill(0);
            const kernel = [0,1,0, 1,1,1, 0,1,0];
            
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    let completeMatch = true;
                    
                    for (let u = 0; u < 3; u++) {
                        for (let v = 0; v < 3; v++) {
                            const kernelIndex = u * 3 + v;
                            
                            if (kernel[kernelIndex] === 1) {
                                const checkI = i + u - 1;
                                const checkJ = j + v - 1;
                                
                                if (checkI < 0 || checkI >= 6 || checkJ < 0 || checkJ >= 6) {
                                    completeMatch = false;
                                    break;
                                }
                                
                                const checkIndex = checkI * 6 + checkJ;
                                if (image[checkIndex] === 0) {
                                    completeMatch = false;
                                    break;
                                }
                            }
                        }
                        if (!completeMatch) break;
                    }
                    
                    if (completeMatch) {
                        const resultIndex = i * 6 + j;
                        result[resultIndex] = 1;
                    }
                }
            }
            
            return result;
        }

        function performDilationOn6x6(image) {
            const result = Array(36).fill(0);
            const kernel = [0,1,0, 1,1,1, 0,1,0];
            
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    const pixelIndex = i * 6 + j;
                    
                    if (image[pixelIndex] === 1) {
                        for (let u = 0; u < 3; u++) {
                            for (let v = 0; v < 3; v++) {
                                const kernelIndex = u * 3 + v;
                                
                                if (kernel[kernelIndex] === 1) {
                                    const newI = i + u - 1;
                                    const newJ = j + v - 1;
                                    
                                    if (newI >= 0 && newI < 6 && newJ >= 0 && newJ < 6) {
                                        const resultIndex = newI * 6 + newJ;
                                        result[resultIndex] = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        function presetOpeningNoisy() {
            openingData.original = [0,0,0,0,0,0, 0,1,0,1,0,0, 0,0,1,1,1,0, 1,0,1,1,0,0, 0,0,1,1,1,0, 0,0,0,1,0,0];
            openingData.eroded = Array(36).fill(0);
            openingData.final = Array(36).fill(0);
            renderOpeningGrids();
            updateProgress('openingProgress', 0);
            updateStepInfo('openingStepInfo', 'Preset √ÆncƒÉrcat: imagine cu zgomot »ôi obiecte mici');
        }

        function resetOpening() {
            openingData.original = [0,0,0,0,0,0, 0,1,0,1,0,0, 0,0,1,1,1,0, 1,0,1,1,0,0, 0,0,1,1,1,0, 0,0,0,0,0,0];
            openingData.eroded = Array(36).fill(0);
            openingData.final = Array(36).fill(0);
            renderOpeningGrids();
            updateProgress('openingProgress', 0);
            updateStepInfo('openingStepInfo', 'Reset complet! ApasƒÉ "AplicƒÉ Deschiderea"');
        }

        // === FUNC»öII PENTRU √éNCHIDERE ===
        function renderClosingGrids() {
            renderGrid('closingOriginal', closingData.original, 6, true, 'closing');
            renderGrid('closingDilated', closingData.dilated, 6, false);
            renderGrid('closingFinal', closingData.final, 6, false);
        }

        function performClosing() {
            // Pasul 1: Dilatare
            const dilated = performDilationOn6x6(closingData.original);
            closingData.dilated = dilated;
            
            // Pasul 2: Eroziune pe rezultatul dilatƒÉrii
            const final = performErosionOn6x6(dilated);
            closingData.final = final;
            
            renderClosingGrids();
            updateStepInfo('closingStepInfo', '√énchidere aplicatƒÉ! Golurile au fost umplute.');
            updateProgress('closingProgress', 100);
        }

        function presetClosingGaps() {
            closingData.original = [0,0,0,0,0,0, 0,1,1,0,1,0, 0,1,0,0,1,0, 0,1,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0];
            closingData.dilated = Array(36).fill(0);
            closingData.final = Array(36).fill(0);
            renderClosingGrids();
            updateProgress('closingProgress', 0);
            updateStepInfo('closingStepInfo', 'Preset √ÆncƒÉrcat: imagine cu goluri de umplut');
        }

        function resetClosing() {
            closingData.original = [0,0,0,0,0,0, 0,1,1,0,1,0, 0,1,0,0,1,0, 0,1,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0];
            closingData.dilated = Array(36).fill(0);
            closingData.final = Array(36).fill(0);
            renderClosingGrids();
            updateProgress('closingProgress', 0);
            updateStepInfo('closingStepInfo', 'Reset complet! ApasƒÉ "AplicƒÉ √énchiderea"');
        }
    </script>